\section{可验证计算}
外包计算（Outsource Computation，OC） \cite{USENIX:GreHohWat11, C:ChuKalVad10} 是一种客户端-服务端模型，允许客户端将计算过程委托给服务器，而客户端仅提供输入并接受输出。在外包计算中，客户端通常计算能力有限，这一模型使得客户端可以利用服务端的计算能力来完成复杂的任务。在这一过程中，一个重要的问题是如何验证服务端的计算结果。可验证计算（Verifiable Computation，VC）是解决这一问题的一种方法。在VC中，服务端需要提供一个证明，证明其计算结果是正确的。客户端可以通过验证这一证明来确保服务端的计算结果的正确性。显然，验证这一证明的过程必须是高效的，验证效率需要高于计算效率，否则客户端可以直接计算结果而不需要将计算外包。

PIR可以看作一种特殊的外包计算。其特殊之处在于，客户端外包给服务器的是数据库的存储而非计算。同时，客户端还要保护己方输入，不能将明文请求直接传输给服务器。在传统的PIR协议中，往往不考虑服务器给出的查询结果是否可靠。换言之，传统PIR协议假设服务器是半诚实的。然而如前文所述，验证计算结果一直是外包计算的一个重要构成部分。如 \cite{VeriSimplePIR, APIR, SVPIR18} 等工作拓展了这一场景，讨论了如何与恶意的服务器进行PIR查询。我们首先给出一个基于离线-在线PIR框架的可验证PIR定义：

\begin{definition}[可验证PIR]
    一个\textit{可验证PIR}方案$\Pi$允许客户端从数据库$\db$中检索记录$\db_\dbidx$，而不向$\servercount$个服务器中任何一个泄露索引$\dbidx$。该方案由算法元组$\Pi = (Setup, Hint, Query,\\ Answer, Reconstruct, Refresh)$组成：

    离线部分：
    \begin{itemize}[leftmargin=*]
        \item $Setup(1^\lambda,\dbsize) \rightarrow \query_\hint$。给定数据库大小$\dbsize$和安全参数$\lambda$，生成Hint查询$\query_\hint$。
        \item $Hint(\db, \query_\hint) \rightarrow \hint$。给定数据库$\db$和Hint查询$\query_\hint$，生成Hint $\hint$。
    \end{itemize}
    在线部分：
    \begin{itemize}[leftmargin=*]
        \item $Query(\hint, \dbidx) \rightarrow (\query, \clientstate)$。给定Hint $\hint$和要查询的索引$\dbidx$，生成查询$\query$。注意，查询$\query$可能包含多个子查询。客户端生成并保存一个私有状态$\clientstate$。
        \item $Answer(\db, \query) \rightarrow \answer$。给定查询$\query$，生成回答$\answer$。
        \item $Reconstruct(\clientstate, \hint, \answer) \rightarrow \{\db_\dbidx, \bot\}$。给定回答$\answer$，使用Hint $\hint$和私有状态$\clientstate$重构出记录$\db_\dbidx$，或是拒绝并输出 $\bot$。
        \item $Refresh(\clientstate, \hint, \answer) \rightarrow \hint$。给定回答$\answer$和私有状态$\clientstate$，更新Hint $\hint$。
    \end{itemize}
    可验证PIR算法除了满足\textbf{正确性}与\textbf{隐私性}之外，还需要额外满足\textbf{完整性}：
    \begin{itemize}
        \item \textbf{完整性}：对于任意安全参数$\lambda$，任意数据库$\db$和索引$\dbidx$，任意概率多项式时间敌手 $\adversary$作为服务器之一与客户端交互时，客户端输出一个错误答案 $\db_\dbidx' \neq \db_\dbidx$ 的概率小于 $\negl(\lambda)$。
    \end{itemize}
\end{definition}

\subsection{选择失败攻击}
在外包计算的过程中，客户端如果发现服务器的不诚实行为，可以提出证明并拒绝为服务付费 \cite{chen2012efficient, carbunar2011payments}。然而，在包含PIR在内的一部分场景中，这种证明可能是危险的。服务器可以利用这种证明收集客户端的查询信息。

选择失败攻击的概念最早提出于2006年 \cite{Kiraz2006API}。这种攻击利用了“证明验证失败”这一事实。在这种攻击里，恶意的服务器刻意构造一些错误的答案，以期从客户端的反应中推测客户端的输入。举例而言，如果客户端采用数字签名分别保护数据库中每一条记录的可靠性，而服务器仅修改了第一条记录，将其改为了某些不能通过数字签名验证的错误值。那么，如果客户端请求的正是第一条记录，它就会拒绝服务器的答案。相反，如果客户端请求的不是第一条记录，客户端就会接受服务器的答案。由此，服务器可以确认客户端是否在请求第一条记录。这与PIR的性质相违背。

因此，在本文中，为了突出这种攻击的重要性，我们采用了一种更可靠的隐私性定义：

\begin{definition}[抗选择失败攻击的隐私性]
    \label{def:privacy-sfa}
    对于任意计算安全参数$\lambda$，一个可验证PIR协议 $\Pi$ 是\textit{抗选择失败攻击隐私}的，当且仅当对于任意数据库$\db$，存在一概率多项式时间模拟器 $\simulator(1^\lambda, \dbsize)$，使得对于控制不超过$\servercount$台服务器中$\threshold$台的任意概率多项式时间敌手 $\adversary$，$\adversary$无法以超过 $\negl(\lambda)$的优势区分下述两个世界：
    \begin{itemize}
        \item \textbf{世界 0}: 在每个查询时刻 $t$，$\adversary$ 选择下一次查询的索引 $\dbidx_t$， $\client$ 将 $\dbidx_t$ 作为查询的索引。查询完成后，如果验证通过，客户端向 $\adversary$ 输出 $1$ ，否则输出 $0$.
        \item \textbf{世界 1}: 在每个查询时刻 $t$，$\adversary$ 选择下一次查询的索引 $\dbidx_t$。$\simulator$ 在不知道  $\dbidx_t$ 的情况下执行协议, 但是如果 $\adversary$ 给出了正确的答案，$\simulator$会收到一个比特 $1$，否则收到 $0$。 $\simulator$ 在查询完成后将这个比特输出给 $\adversary$。
    \end{itemize}

    $\adversary$ 可以以任意方式背离原协议。
\end{definition}

没有验证环节的PIR显然是抗选择失败攻击的。在可验证的PIR中，协议必须仔细分析由验证带来的隐私泄露。一些先前的工作如\cite{APIR, VeriSimplePIR}将数据库与信息摘要绑定，并进行线性运算以检查整个数据库。然而，在这些协议中，服务器处理一次查询的时间至少是线性的，无法用于亚线性复杂度的PIR协议。