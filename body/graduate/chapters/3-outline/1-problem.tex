\section{需求分析}

近年来，区块链中的一个新兴概念“去中心化物理基础设施网络（Decentralized Physical Infrastructure Networks，DePIN）”逐渐出现在人们的视野中。在区块链“去中心化”的基本路线上，DePIN将概念从虚拟的数字资产拓展到了实际的服务。例如，Filecoin \cite{filecoin} 允许其用户提供存储服务，以打造一个“存储人类最重要信息的分布式网络”；Fluence \cite{fluence} 则提供类似于传统云计算的服务，允许用户将计算服务部署到网络中。相较于传统云服务的中心化模式，这些DePIN项目允许任何参与者成为算力池的一部分，从而分布式地提供服务。显而易见地，这样的模式能够更充分地利用闲置的算力，最大化地发挥其作用，使资源与需求更好地匹配与结合。PIR与这一模型有着非常好的相性。由于PIR定义中不要求保护数据库地隐私，数据库拥有者可以很容易地将数据库委托给某个区块链网络来提供PIR服务。

然而，相较于传统的中心化服务模式，这种去中心化的委托方式天然地带有零信任特点。内在的分布式要求也使得我们希望PIR服务能够容易地进行横向拓展。在本章的剩余部分，我们进一步展开讨论这一问题。
\subsection{PIR的性能问题}
如前文所述，PIR的效率相较于传统数据库的查询有着非常大的差距。以目前最先进的线性复杂度PIR为例，SimplePIR \cite{SimplePIR} 在 8GiB 大小的数据库中完成一次查询约需要 700 KiB 的通信量与 800ms 的计算。而非隐匿的普通数据库查询仅需要不到 1 KiB 的通信与远小于 1 ms 的计算时间（事实上，查询的瓶颈在于硬盘读写速度而非计算量）。同时，PIR的效率对于查询的数据库大小非常敏感，而传统数据库查询在进行如PIR的单点查询时几乎不受到数据库大小影响。这之中主要原因是PIR要求保护查询者的隐私，服务提供者无法获知查询的具体位置，就无法如传统数据库查询一样利用索引来加速查询。如果我们暂不考虑硬盘-内存的带宽瓶颈，可以认为，通过索引加速的普通数据库单点查询的复杂度总是 $O(\log\dbsize)$，而线性复杂度的PIR的复杂度是 $O(\dbsize)$。线性复杂度与对数复杂度之间的巨大差距铸成了这一性能鸿沟。

如此巨大的性能差距使得PIR的实际应用举步维艰。一方面，冗长的计算时间使得查询的延迟变得很高，这对于很多实时性要求较高的应用，如UI渲染、DNS请求等来说是不可接受的。另一方面，高通信量与高计算量也让提供服务的成本大幅上升。综上所述，为了使得PIR能够在实际应用中发挥作用，迫切地需要一种更高效的PIR算法。

\subsection{PIR的存储和拓展性问题}
在一部分PIR协议，尤其是基于同态加密的PIR协议中，服务器会保存编码过的数据库。编码后的数据库相较于原始的数据库会有一定程度上的体积膨胀。实验表明，在将一个 8GiB 大小的数据库编码后，其需要使用 40GiB 存储空间\cite{SimplePIR}。这种体积膨胀会使得数据库的存储成本上升。PIR的另一个困境使得这一问题更加严重：由于局部性暴露了查询之间的关联，PIR的查询天然地要求消灭所有查询的局部性。因此，缓存机制对于PIR的效率提升几乎没有帮助。在线性复杂度的PIR协议中，服务器需要将整个数据库从硬盘读入内存一次以进行计算，这会成为严重的瓶颈——以 AWS GP3 存储服务 \cite{AWSEBSGP} 为例，其提供的硬盘最大吞吐量仅为 1000 MiB/s，40GiB 大小的数据库仅读入内存就需要 40s。而CPU计算的吞吐量超过 10000 MiB/s，远远超过了硬盘吞吐量。因此，绝大部分时间都会耗费在等待硬盘IO上。目前，大部分PIR协议并不考虑这一问题，而是假设服务器可以在内存中存储整个数据库。然而，这一假设在实际应用中很难成立。当数据库规模不断扩大，服务器的内存容量将迅速耗尽。

一部分PIR工作中会探讨是否应该将“客户端直接存储整个数据库”作为一种可能的解决方案。在我们所讨论的问题中，直接存储整个数据库是不现实的。当我们考虑数据库的可拓展性时，客户端有限的存储空间会首先成为瓶颈。应当考虑到，常见的客户端（如手机，个人电脑，物联网设备等）往往有着相较于服务器而言极为有限的内存和存储空间，PIR协议不应当对客户端产生太大的计算与存储压力。实际生产中，大小数 TB 的数据库并不罕见，而这样的数据库在现有的PIR协议中是无法处理的。为使得PIR能够处理大规模数据库，我们需要一种能够横向拓展的PIR算法。

\subsection{去中心化服务带来的零信任问题}
在讨论“去中心化”，“外包计算”等概念时，我们不可避免地要面临一个问题：如何保证服务的正确性？服务承接者可能并不是诚实的。一个非诚实的服务提供者可能会故意提供错误的结果以误导用户或节约计算量。即使是诚实的服务提供者也可能因为硬件软件故障而导致结果出错。在传统的中心化服务中，这一问题相对容易解决：服务提供者可以通过监控、审计等手段来保证服务的正确性。从另一个角度来看，服务的正确性是由服务提供者的信誉所保障的。然而，在去中心化服务中，这一问题变得更加困难。服务提供者可能是匿名的，监控、审计等手段无法直接应用，零信任环境下更不应该把信誉作为评判标准。
我们强调，在这样的环境中，保证正确性并非只是用户的需求，而是委托者，服务提供者，用户三方面的共同要求。对于委托者而言，正确性保证是其委托的基础。如果没有正确性，它与服务提供者的协议就无法成立。对于服务提供者而言，正确性保证是其获得报酬的凭证。服务提供者通过证明其提供了正确的服务获取报酬。对于用户而言，正确性保障其能正常地使用服务。因此，在去中心化服务中，保证服务的正确性是十分迫切的需求。

在目前的项目中，这一问题往往是通过可验证计算解决的。即，服务提供者向用户提供一个计算证明，证明其计算的正确性。然而，这一方法往往需要额外的计算，使得服务的效率下降。朴素的证明，如非交互式零知识证明（Non-interactive Zero-Knowledge proof，NIZK），生成证明的过程往往比计算本身慢数个数量级。如何在保证服务的正确性的同时不影响服务的效率是棘手的问题。

在前人的工作 \cite{APIR} 中，一种名为“选择失败攻击”的攻击方式被引入了PIR。这种攻击方式利用验证计算证明的过程来获取用户的隐私。服务提供者可能刻意地将数据库中的一部分记录损坏，以使得用户只能在访问部分数据时获得正确的结果。一旦服务提供者得知了用户的验证结果，它就能推断出用户访问的是否是完好的数据。这种攻击使得传统的利用数字签名，消息认证码（Message Authentication Code，MAC）等方式来保证数据库中记录可靠性的方式不再可行。

另外的，我们注意到去中心化服务带来的分布式特性也使得服务的可用性问题浮出水面。在分布式服务中，保障服务的可用性是一个重要命题。为了在硬件损坏、网络波动等条件下，保证用户能够持续访问服务，传统的分布式集群采用冗余，备份等方式保证服务的可用性，通过将服务切换至备用节点屏蔽故障的节点。而在去中心化的环境中，缺少了中心化的协调与调度机制，我们需要更加可靠的手段来保障服务的正常运行。
