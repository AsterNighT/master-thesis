\section{编码与PIR的关系}
在传统的PIR协议中，纠错码一般用于多服务器PIR场景下。常见的一种定义为$t$-PIR。即客户端向多台服务器发起请求，允许其中$t$台服务器共谋，分享客户端发送的请求以尝试得到查询的信息。在这样的情况下，要求共谋的服务器不能得到查询索引的信息。此时纠错码可以作为对查询请求编码的方式，保证至少$t+1$台服务器才能解密出查询的内容。

同时，一些研究\cite{10.1007/978-3-031-22368-6_3}也注意到，纠错码也可以用于它的一般用途，即纠正PIR查询中的错误。在PIR这类在线服务中，由于网络传输、硬件故障、甚至是服务器恶意攻击等原因，查询错误是很难避免的。纠错码可以用于纠正这些错误。

\subsection{可验证PIR与纠删码}

{讲一下可验证的意义，以reed solomon code 为例，加倍了纠错阈值}
我们注意到，在这些基于纠错码的多服务器协议中，如果每个服务器的回答都可以单独验证，那么纠错码就可以简化为纠删码。以Reed-solomon编码为例，当作为纠错码时，其$(n,m,e)$编码方案一般需要满足$m=n+2*e$。如果作为纠删码使用，则只需要$m=n+e$。如果$m,n$的值都不变（对应服务器总数与数据库大小不变），那么$e$的大小就变为原先的两倍。这说明进行这一简化后，相应的纠错阈值$t$翻倍了。因此，即便纠错码可以提供验证服务器答案的功能，如果协议还允许单独验证每个服务器的答案，纠错的阈值可以大大提高。

\subsection{PIR中的数据库划分需求}
PIR与传统的数据库查询有一个很大的不同点：由于其查询的隐私性要求，服务器收到的请求总是\textbf{无局部性}的。这体现在两方面：
\begin{enumerate}
    \item 在线性复杂度的PIR协议中，服务器总是为处理单个请求遍历整个数据库。
    \item 在亚线性复杂度的PIR协议中，服务器在处理请求时访问的记录是无法预测的。
\end{enumerate}

这导致传统数据库基于索引与缓存的查询加速机制完全失效。我们无法通过既往查询缓存查询结果。同时，由于记录都是线性存储于表中的，也不必使用索引加速访问某一记录的过程。事实上，大部分PIR协议都直接假设整个数据库位于内存中，忽略了从硬盘读取数据库内容的过程。然而，这一假设在实际应用中是不合理的,数据库的大小可能超过单台服务器可用的内存总量。有一些研究讨论了将数据库进行划分后进行查询\cite{RAID-PIR}以提高效率，但他们并未解决划分后需要进行多点查询导致的数据可靠性问题。对数据库进行划分后，查询涉及的服务器增加，服务器集群中出现故障的概率也相应提高。因此，我们需要一种方法来保证数据库划分后的数据可靠性。

由于进行数据库划分这一任务需要沟通协商，或是有一个中心化的协调人。很难认为参与数据库划分的服务器之间不会共谋。因此，在本章提出的协议中，我们采用一种最强的攻击模型，即假设所有服务器都是由同一个实体控制的。由此，我们可以得到一个基于纠删码划分的PIR协议框架。
