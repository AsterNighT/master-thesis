\section{国内外研究现状}

根据参与的服务器数量，PIR协议可分为单服务器PIR协议和多服务器PIR协议。其中单服务器协议只有一台服务器参与，而多服务器协议中，客户端会与多台服务器进行交互，每台服务器都拥有一份相同的数据库副本。根据协议的效率，PIR协议可分为线性PIR协议和亚线性PIR协议，这是由协议运行的渐进复杂度决定的，如果运行一次查询复杂度为亚线性，那么协议就是亚线性的，反之则一般为线性。根据安全模型，PIR协议又可分为可验证和非可验证两类：可验证PIR协议允许服务器返回错误答案，而客户端可以对答案进行验证以保证正确性，而非可验证PIR要求服务器总是给出正确答案。综合这些分类组合，本节将重点介绍PIR领域中四个主要方向的研究进展：线性单服务器、亚线性多服务器、亚线性单服务器以及可验证PIR协议在国内外学术界的研究现状。

\subsection{线性单服务器PIR协议}
线性单服务器PIR协议通常采用同态加密技术构建，如XPIR \cite{EPRINT:ABFK14}、SealPIR \cite{SP:ACLS18}、MulPIR \cite{USENIX:ALPRSSY21} 和SPIRAL \cite{SP:MenWu22} 等。这些协议将大小为$\dbsize$的数据库视为一个 $\dbsize = n^d$ 的$d$维超立方体。客户端向服务器发送经加密的、由 0 和 1 构成的独热查询向量，服务器对查询向量与数据库执行乘法运算，并将结果返回给客户端，客户端解密以获取查询结果。在这一路线上的一项重要工作是 SimplePIR \cite{SimplePIR}。在一次SimplePIR查询中，服务器大约需要对每条记录进行一次乘法和一次加法操作，通过在同态加密运算中进行预处理，显著提高了查询效率。效率提升的代价是服务器需要对数据库进行预处理，并要求客户端在查询之前下载一个大小为 $O(\sqrt{\dbsize})$ 的提示（Hint）。由于PIR要求保护客户端的查询隐私，这些协议在每次查询时都需要访问数据库中的每一条记录。这一开销是不可避免的，若某条记录在一次请求中未被访问，那么请求的记录必定不是该记录。这也导致PIR的效率对数据库大小非常敏感。这些协议的查询复杂度为 $O(\dbsize)$。

\subsection{亚线性多服务器PIR协议}

在涉及多台服务器的协议中，客户端会与多台服务器进行交互，每台服务器都拥有一份相同的数据库副本。一般假设这些服务器不（完全）共谋，因此协议可以通过信息论而非纯计算方式来保护隐私，从而降低计算量与通信量。传统的多服务器PIR协议通信成本远低于单服务器PIR协议，但仍然需要线性的计算开销。例如，在DPF-PIR\cite{DPF-PIR}中，客户端向两台服务器发送两个压缩后的向量$x$和$y$，使得$x + y$构成先前提到的独热查询向量。两台服务器在向量与数据库进行乘法运算后将答案返回给客户端，客户端将答案相加以获得查询的记录。这种协议的一大优势在于不依赖昂贵的同态加密运算，也不需要复杂的预处理和Hint下载，从而显著提高了计算效率。然而，这种协议的计算复杂度仍然是线性的。

Corrigan-Gibbs和Kogan提出了第一个亚线性PIR协议\cite{EC:CorKog20}。他们意识到，尽管单次PIR查询已被证明至少需要线性的计算量，但却没有人考虑过多次查询的均摊复杂度。如果协议可以进行某些预处理，并将预处理的开销均摊到许多高效的查询上，就可能实现均摊亚线性的复杂度。他们提出的协议包括一台客户端和两台服务器，分为离线阶段和在线阶段。在离线阶段，客户端从一台服务器上获取一些数据库信息，包括大约$\Theta_\lambda(\sqrt{\dbsize})$个由数据库中记录构成的随机集合以及每个集合中对应所有记录的和。在在线阶段，客户端在这些集合中寻找包含其想要查询记录的集合，然后在另一台服务器上使用这个集合进行查询。这种协议的核心组成部分是一种被称为“可穿孔伪随机函数”（Puncturable Pseudorandom Function，PPRF）的原语。为了保障协议的隐私性，该协议存在正确性缺陷，需要并行多个实例来确保查询的成功。该协议的均摊渐近复杂度达到了$\softO(\sqrt{\dbsize})$，突破了线性复杂度的限制。他们提出的协议已成为亚线性复杂度PIR协议的基础，并被一系列后续工作\cite{Piano,MIR23,EC:CorHenKog22,USENIX:KogCor21,C:LazPap23}所继承。

这些研究的一部分集中在提高协议的效率。Corrigan-Gibbs和Kogan提出的协议中，隶属查询并不高效，即客户端无法高效地查找包含待查询记录的集合。为了在查询时找到相应的集合，客户端需要进行 $O_\lambda(\dbsize)$ 的计算，或者使用 $\softO(\dbsize^{5/6})$ 的空间缓存结果。因此，一些研究\cite{C:LazPap23,C:SACM21}改进了集合的组织结构，采用了更高效的PPRF构造。例如，TreePIR\cite{C:LazPap23}提出了一种被称为“弱可穿孔伪随机函数（weakly Puncturable Pseudorandom Function，wPPRF）”的原语，通过对数据库进行分块，有效地支持高效的隶属查询，同时避免了原协议中需要并行多个实例的情况。

\subsection{亚线性单服务器PIR协议}
另一部分工作\cite{Piano,EC:CorHenKog22}致力于将亚线性PIR协议移植到单服务器环境中。在亚线性PIR协议中，集合不能从一个服务器获取然后在同一台服务器上使用，这使得移植存在一定困难。Corrigan-Gibbs等人首先完成了这一工作\cite{EC:CorHenKog22}。他们提出了一种将多服务器PIR协议编译为单服务器PIR协议的通用编译器，利用备用集合与同态加密技术替代了多服务器协议中一台服务器的功能。然而，他们的协议与最初的多服务器协议一样，仍需要并行实例来确保正确性，并要求客户端缓存大量计算结果以确保在线查询的效率。Piano\cite{Piano}结合了Corrigan-Gibbs等人的工作\cite{EC:CorHenKog22}与TreePIR\cite{C:LazPap23}中的技术，提出了一个高效的单服务器亚线性PIR协议。Piano的作者指出，实际上，将整个数据库通过流式传输到客户端，然后让客户端在本地计算Hint是更为现实的做法。此外，他们提出了第一个真正的单服务器亚线性PIR协议实现。该协议的通信复杂度为 $O(\sqrt{\dbsize})$，计算复杂度为$O_\lambda(\dbsize)$。

\subsection{可验证的PIR协议}

一些研究致力于研究可验证的PIR，将PIR协议移植到恶意安全模型。该模型最早于1995年提出\cite{FOCS:CGKS95}，并得到进一步的研究\cite{SCN:BeiSta02, USENIX:DevGolHen12,SVPIR18, MerkleTree}。早期的研究通常集中在如何证明计算的正确性上，即要求输出与某个数据库一致，但并未考虑服务器是否在错误的数据库上运行协议。近期的一些研究 \cite{VeriSimplePIR, APIR} 探讨了如何确保服务器返回的数据与预定义的数据库一致。在 APIR\cite{APIR} 中，研究者系统地定义了可验证PIR，并提出了单服务器、多服务器以及函数秘密共享的可验证协议。他们的多服务器协议基于默克尔证明（Merkle Proof），单服务器协议基于容错学习问题（Learning With Error, LWE）和判定性Diffie-Hellman假设（Decisional Diffie-Hellman，DDH）。同时，他们还注意到了在PIR中“选择失败攻击”的影响。然而，他们提出的协议在通信量和计算量上都相当低效，缺乏实用性。另一项工作 VeriSimplePIR \cite{VeriSimplePIR} 在SimplePIR的基础上增加了验证功能，通过预先运行一个验证协议，以较小代价将协议迁移到恶意安全模型。

\subsection{目前研究存在的问题}
目前，亚线性PIR协议引入了一种被本文称为“虚构查询”的新问题。这一问题的核心在于在进行一次查询时，客户端实际上执行了多次查询，除了一条真实查询外，其他都是虚构的，用于混淆真实查询。这种虚构查询不仅降低了查询的效率，还导致客户端难以验证这些查询的结果，从而使得这些协议在面临恶意攻击时无法同时确保正确性和隐私性。同时，可验证PIR协议方向的工作都基于线性复杂度的PIR协议构建，目前尚未出现可验证的亚线性复杂度PIR协议。