\section{国内外研究现状}
\todo{这里恐怕给不出几个中文文献，会有问题么？}
\todo{基本可以照抄Crust，但是得再多讲讲single-server PIR，以及展开地更详细一点。包括现有的RaidPIR之类的研究。}
\todo{简要地介绍一下高可用，纠错码相关地东西，应该在分布式数据库那一块。}
\todo{讨论一下可更新数据库的问题。}
\todo{有必要提区块链相关的研究么？也许应该讨论一下DePIN, PoPW这种商业模式上的研究？}

针对PIR的研究可以按不同的角度分类。从提供服务的服务器数量区分，可以分为单服务器和多服务器PIR。从运行协议的效率区分，可以分为线性复杂度的PIR与亚线性复杂度的PIR。从考虑的安全模型区分，可以分为半诚实的PIR与可验证的PIR。本节介绍PIR的发展状况，以使读者更好地理解本文的设计思路和方向。

\subsection{线性单服务器PIR}
容易想到，由于PIR的定义中不保护数据库的隐私，直接将数据库下载到客户端本地也满足对于PIR的定义。但这样的协议对于客户端的存储空间提出了很高的要求，同时也需要较大的带宽以传输整个数据库。后续研究逐渐发展出基于同态加密的单服务器PIR协议，如XPIR \cite{EPRINT:ABFK14}、 SealPIR \cite{SP:ACLS18}、MulPIR \cite{USENIX:ALPRSSY21} 与 SPIRAL \cite{SP:MenWu22}。这些协议将数据库看作一个 $n^d$ 的超立方体，通过查询向量与数据库之间的同态加密运算进行查询。其后的一项重要工作是 SimplePIR \cite{SimplePIR}。这篇文章通过预处理同态加密运算中的一部分，使得查询效率大大提高。不可避免地，运行每一次查询时，这些协议都需要访问数据库中的每条记录至少一次。显而易见，如果某条记录在一次请求中没有被访问，那么请求的记录一定不是这一条。这使得PIR的效率对于数据库的大小非常敏感。这些协议的查询复杂度为 $O(N)$，被称作是是线性复杂度的PIR。

\subsection{亚线性多服务器PIR}

在涉及多个服务的方案中，客户端会与多台服务器进行交互。每个服务器都拥有一份数据库副本。传统的多服务器 PIR 方案通信成本远低于单服务器PIR，但是仍然需要线性的计算开销。Corrigan-Gibbs 和 Kogan 在 \cite{CK20} 中提出了第一个亚线性 PIR 协议。这种协议中有一台客户端和两台服务器。协议分为离线阶段和在线阶段。离线阶段中，客户端从一台服务器上获取一些被称为 hint 的数据库信息。在线阶段中，客户端在另一台服务器上使用这些 hint 以进行查询。这种协议的组成核心是一种叫做“可穿孔伪随机函数”（Puncturable Pseudorandom Function，PPRF）的原语。此协议的正确性存在缺陷，所以需要并行多个实例来保证查询的成功。这使得整个协议在实践中非常低效，但其渐近复杂度达到了 $\softO(\dbsize)$，突破了线性复杂度的PIR的限制。这篇文章提出的框架成为了亚线性复杂度 PIR 的基本结构，被之后的一系列工作 \cite{Piano,MIR23,CHK22,Checklist,TreePIR} 所继承。

这些工作中的一部分专注于提升最初框架的效率。\cite{CK20} 中的 hint 构造不能高效地进行隶属测试。为了在查询时找到合适的 hint，客户端必须在进行 $O_\lambda(\dbsize)$ 的计算或使用 $\softO(\dbsize^{5/6})$ 的空间缓存结果中二择其一。两者都不是令人满意的选择。因此，\cite{TreePIR,C:SACM21} 等工作改进了 hint 的组织结构，使用了更高效的 PPRF 构造。例如，\cite{TreePIR} 提出了一种称为“弱可穿孔伪随机函数（weakly Puncturable Pseudorandom Function，wPPRF）”的原语。他们的构造能够在支持高效隶属查询的同时，免去了原构造中并行多个实例的需求。然而，他们的构造引入了一种本文称之为“虚构查询”的新问题。这一问题导致了这些协议很难在恶意攻击者存在时保证隐私。

\subsection{亚线性单服务器PIR}
另一部分工作 \cite{Piano,CHK22} 致力于将亚线性PIR移植到单服务器环境中。由于 hint 不能从一台服务器获取，又在这一台服务器使用，这一移植并不容易。Corrigan-
Gibbs 首先完成了这一工作，但他们的协议和最开始的多服务器协议一样，需要并行实例来确保正确性，并且需要客户端缓存大量的计算结果。Piano \cite{Piano} 结合了 \cite{CHK22} 与 \cite{TreePIR} 中的技术，提出了一个高效的单服务器亚线性 PIR 协议。这一协议的通信复杂度为 $O(\sqrt{\dbsize})$， 计算复杂度为$O_\lambda(\dbsize)$。尽管这一协议在效率上更进一步，它和之前提到的TreePIR一样有着“虚构查询”的问题。本文所提出的亚线性PIR框架希望解决这一问题，从而使得向恶意安全模型迁移成为可能。

\subsection{可验证的PIR}
一些工作研究了可验证PIR这一课题，致力于将PIR迁移到恶意安全模型上。这一模型最初在 \cite{FOCS:CGKS95} 中提出，在 \cite{SCN:BeiSta02, USENIX:DevGolHen12,SVPIR18, MerkleTree} 中被进一步研究。最近的一些工作包括 \cite{VeriSimplePIR, APIR}。在 \cite{APIR} 中，作者系统地定义了可验证PIR，并提出了单服务器，多服务器与函数秘密分享的可验证协议。同时，他们还注意到了选择失败攻击在PIR中的影响。然而，他们提出的协议在通信量与计算量上都相当低效，并不实际。另一项工作 VeriSimplePIR \cite{VeriSimplePIR} 则在 SimplePIR 的基础上增加了验证能力，以比较小的代价将协议迁移到了恶意安全模型上。这些工作都是基于线性复杂度的PIR构造的，目前尚没有可验证的亚线性复杂度PIR协议。本文希望能够填补这一方面的空白。


