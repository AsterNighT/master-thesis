\section{国内外研究现状}

本节介绍PIR的发展状况，以使读者更好地理解本文的设计思路和方向。

\subsection{线性单服务器PIR}
由于PIR不保护数据库的隐私，直接将数据库下载到客户端本地也满足PIR的定义。但这样的协议对于客户端的存储空间产生了很大的压力，同时也需要较大的带宽以传输整个数据库。后续研究逐渐发展出基于同态加密的单服务器PIR协议，如XPIR \cite{EPRINT:ABFK14}、 SealPIR \cite{SP:ACLS18}、MulPIR \cite{USENIX:ALPRSSY21} 与 SPIRAL \cite{SP:MenWu22}。这些协议将数据库看作一个 $n^d$ 的超立方体。客户端向服务器提交一个加密过的、由$0$和$1$构成的独热查询向量，服务器将查询向量与数据库进行乘法运算，并将结果返回给客户端。客户端解密得到查询结果。继承这一路线的一项重要工作是 SimplePIR \cite{SimplePIR}。这项工作通过预处理同态加密运算中的一大部分，使得查询效率大幅提高。在一次 SimplePIR 的查询中，服务器大约需要对每一条记录做一次乘法与一次加法。效率提高的代价是服务器需要对数据库进行预处理，并且需要客户端在查询之前下载一个大小为$O(\sqrt{\dbsize})$的提示（Hint）。由于PIR要求保护客户端的查询隐私，运行每一次查询时，这些协议都需要访问数据库中的每条记录至少一次。这是不可避免的，其中的原因显而易见——如果某条记录在一次请求中没有被访问，那么请求的记录一定不是这一条。这使得PIR的效率对于数据库的大小非常敏感。这些协议的查询复杂度为 $O(\dbsize)$，被称作线性复杂度的PIR。

\subsection{亚线性多服务器PIR}

在涉及多台服务器的方案中，客户端会与多台服务器进行交互。每台服务器都拥有一份相同的数据库副本。一般假设这些服务器不（完全）共谋，于是协议就可以通过信息论而非纯计算方式保护隐私，以此降低计算量与通信量。传统的多服务器 PIR 方案通信成本远低于单服务器PIR，但是仍然需要线性的计算开销。例如在 DPF-PIR \cite{DPF-PIR}中，客户端向两台服务器发送两个压缩后的向量 $x,y$，使得 $x + y$ 是我们先前提到的独热查询向量。两台服务器在向量与数据库之间做乘法运算后将答案返回给客户端，客户端将答案相加后得到查询的记录。这种协议的一大优势是不依赖于昂贵的同态加密运算，也不需要复杂的预处理与Hint下载，从而大幅提升了计算效率。然而这种协议的计算复杂度仍然是线性的。

Corrigan-Gibbs 和 Kogan 提出了第一个亚线性 PIR 协议 CK20\cite{CK20}。他们意识到，尽管单次PIR查询已经被证明至少需要线性的计算量，却没有人考虑过多次查询的均摊复杂度。如果协议可以进行某些预处理，并将预处理的开销均摊到许多高效的查询上，就可能得到均摊亚线性的复杂度。他们提出的协议中有一台客户端和两台服务器，分为离线阶段和在线阶段。离线阶段中，客户端从一台服务器上获取一些数据库信息。这些信息包括大约 $\Theta_\lambda(\sqrt{\dbsize})$ 个由数据库中记录构成的随机集合，以及每个集合中对应所有记录的和。在线阶段中，客户端在这些集合中寻找包含其想要查询记录的集合，在另一台服务器上使用这个集合以进行查询。这种协议的组成核心是一种叫做“可穿孔伪随机函数”（Puncturable Pseudorandom Function，PPRF）的原语。为保障协议的隐私性，此协议的正确性存在缺陷，需要并行多个实例来保证查询的成功。协议均摊渐近复杂度达到了 $\softO(\sqrt{\dbsize})$，突破了线性复杂度的限制。这篇文章提出的框架成为了亚线性复杂度 PIR 的基本结构，被之后的一系列工作 \cite{Piano,MIR23,CHK22,Checklist,TreePIR} 所继承。

这些工作中的一部分专注于提升最初框架的效率。CK20\cite{CK20} 中的集合构造不能高效地进行隶属测试，即客户端无法高效地寻找一个包含欲查询记录的集合。为了在查询时找到合适的集合，客户端必须进行 $O_\lambda(\dbsize)$ 的计算或使用 $\softO(\dbsize^{5/6})$ 的空间缓存结果。两者都不那么令人满意。因此，一些工作\cite{TreePIR,C:SACM21}改进了集合的组织结构，使用了更高效的 PPRF 构造。例如，TreePIR\cite{TreePIR} 提出了一种称为“弱可穿孔伪随机函数（weakly Puncturable Pseudorandom Function，wPPRF）”的原语，通过将数据库分块，有效地支持高效隶属查询的同时，免去了原构造中并行多个实例的需求。然而，他们的构造引入了一种本文称之为“虚构查询”的新问题。这一问题的核心是客户端在进行一次查询时实质上进行了多次查询，但除了一条查询之外其他都是虚构的，用于混淆真实查询。这种虚构查询一方面降低了查询的效率，另一方面也导致客户端很难验证这些查询的结果，导致这些协议无法在恶意攻击者存在时同时保证正确性和隐私性。

\subsection{亚线性单服务器PIR}
另一部分工作 \cite{Piano,CHK22} 致力于将亚线性PIR移植到单服务器环境中。在亚线性PIR协议中，集合不能从一台服务器获取，又在同一台服务器使用，这使得移植存在一定困难。Corrigan-Gibbs等人首先完成了这一工作\cite{CHK22}。他们提出了一种将多服务器PIR编译成单服务器PIR协议的通用编译器，利用备用集合与同态加密技术替代了多服务器协议中一台服务器的功能。但他们的协议和最开始的多服务器协议一样，需要并行实例来确保正确性，并且需要客户端缓存大量的计算结果来保证在线查询的效率。Piano \cite{Piano} 结合了Corrigan-Gibbs等人的工作\cite{CHK22} 与TreePIR \cite{TreePIR} 中的技术，提出了一个高效的单服务器亚线性 PIR 协议。他们指出，实际上，将整个数据库都以流式传输到客户端，然后让客户端在本地计算hint才是更现实的做法。他们也给出了第一个真正的单服务器亚线性PIR协议实现。这一协议的通信复杂度为 $O(\sqrt{\dbsize})$， 计算复杂度为$O_\lambda(\dbsize)$。尽管这一协议在效率上更进一步，它和之前提到的TreePIR一样有着“虚构查询”的问题。本文所提出的亚线性PIR框架希望解决这一问题，从而使得亚线性PIR协议向恶意安全迁移。

\subsection{可验证的PIR}
另有一些工作研究了可验证PIR这一课题，致力于将PIR迁移到恶意安全模型上。这一模型最初在1995年 \cite{FOCS:CGKS95} 提出并被进一步研究\cite{SCN:BeiSta02, USENIX:DevGolHen12,SVPIR18, MerkleTree}。早期的工作往往集中于如何证明计算上的正确性，即正确性的假设要求其输出与某个数据库相一致，但不考虑服务器是否直接在错误的数据库上运行协议。最近的一些工作 \cite{VeriSimplePIR, APIR}讨论了如何确保服务器给出的回复与某个预定义的数据库相一致。在 APIR\cite{APIR} 中，作者系统地定义了可验证PIR，并提出了单服务器，多服务器与函数秘密分享的可验证协议。他们的多服务器协议基于默克尔证明（Merkle Proof），单服务器协议基于容错学习问题（Learning With Error, LWE）与判定性Diffie-Hellman假设（Decisional Diffie-Hellman，DDH）。同时，他们还注意到了选择失败攻击在PIR中的影响。然而，他们提出的协议在通信量与计算量上都相当低效，并不实际。另一项工作 VeriSimplePIR \cite{VeriSimplePIR} 则在 SimplePIR 的基础上增加了验证能力，通过预先运行一个验证协议，以比较小的代价将协议迁移到了恶意安全模型上。这些工作都是基于线性复杂度的PIR构造的，目前尚没有可验证的亚线性复杂度PIR协议。本文希望能够填补这一方面的空白。


