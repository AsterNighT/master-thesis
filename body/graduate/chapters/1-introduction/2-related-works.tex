\section{国内外研究现状}

本节介绍PIR的发展状况，以使读者更好地理解本文的设计思路和方向。

\subsection{线性单服务器PIR}
容易想到，由于PIR的定义中不保护数据库的隐私，直接将数据库下载到客户端本地也满足对于PIR的定义。但这样的协议对于客户端的存储空间提出了很高的要求，同时也需要较大的带宽以传输整个数据库。后续研究逐渐发展出基于同态加密的单服务器PIR协议，如XPIR \cite{EPRINT:ABFK14}、 SealPIR \cite{SP:ACLS18}、MulPIR \cite{USENIX:ALPRSSY21} 与 SPIRAL \cite{SP:MenWu22}。这些协议将数据库看作一个 $n^d$ 的超立方体，客户端通过向服务器提交一个加密过的，由01构成的独热查询向量。服务器将查询向量与数据库之间进行乘法，并将结果返回给客户端。客户端解密得到查询结果。继承这一路线的一项重要工作是 SimplePIR \cite{SimplePIR}。这篇文章通过预处理同态加密运算中的一部分，使得查询效率大大提高。SimplePIR 的查询大约需要服务器对每一条记录做一次乘法与一次加法，其代价是服务器需要对数据库进行预处理，并且需要客户端在查询之前下载一个较大的提示（Hint）。由于PIR要求保护客户端的查询隐私，不可避免地，运行每一次查询时，这些协议都需要访问数据库中的每条记录至少一次。这其中的原因显而易见——如果某条记录在一次请求中没有被访问，那么请求的记录一定不是这一条。这使得PIR的效率对于数据库的大小非常敏感。这些协议的查询复杂度为 $O(\dbsize)$，被称作是是线性复杂度的PIR。

\subsection{亚线性多服务器PIR}

在涉及多个服务的方案中，客户端会与多台服务器进行交互。每个服务器都拥有一份数据库副本。这些服务器往往被假设相互之间不（完全）共谋，因此，协议就可以通过信息论而非纯计算方式保护隐私，以此降低计算量与通信量。传统的多服务器 PIR 方案通信成本远低于单服务器PIR，但是仍然需要线性的计算开销。例如在 DPF-PIR \cite{DPF-PIR}中，客户端向两台服务器发送两个压缩后的向量 $x,y$，使得 $x\oplus y$ 是我们先前提到的独热查询向量。两台服务器在向量与数据库之间做乘法后将答案返回给客户端，客户端将答案异或后得到查询的记录。这种协议的一大优势是不依赖于昂贵的同态加密运算，从而大幅提升了计算效率。然而不可避免地，这种协议的计算复杂度仍然是线性的。

Corrigan-Gibbs 和 Kogan 在 \cite{CK20} 中提出了第一个亚线性 PIR 协议。他们意识到，尽管单次PIR查询已经被证明至少需要线性的计算量，却没有人考虑过多次查询的均摊复杂度。如果协议可以进行某些预处理，并将预处理的开销均摊到许多高效的查询上，就可能得到均摊亚线性的复杂度。在这种协议中有一台客户端和两台服务器。协议分为离线阶段和在线阶段。离线阶段中，客户端从一台服务器上获取一些被称为 hint 的数据库信息。这些信息包括大约 $O_\lambda(\sqrt{\dbsize})$ 个由数据库中记录构成的随机集合，以及每个集合中对应所有记录的和。在线阶段中，客户端在这些hint中寻找包含其想要查询的记录，在另一台服务器上使用这个 hint 以进行查询。这种协议的组成核心是一种叫做“可穿孔伪随机函数”（Puncturable Pseudorandom Function，PPRF）的原语。为保障协议的隐私性，此协议的正确性存在缺陷，所以需要并行多个实例来保证查询的成功。这使得整个协议在实践中非常低效，但其均摊渐近复杂度达到了 $\softO(\dbsize)$，突破了线性复杂度的PIR的限制。这篇文章提出的框架成为了亚线性复杂度 PIR 的基本结构，被之后的一系列工作 \cite{Piano,MIR23,CHK22,Checklist,TreePIR} 所继承。

这些工作中的一部分专注于提升最初框架的效率。\cite{CK20} 中的 hint 构造不能高效地进行隶属测试，即客户端无法高效地寻找一个包含了它想要查询记录的hint。为了在查询时找到合适的 hint，客户端必须在进行 $O_\lambda(\dbsize)$ 的计算或使用 $\softO(\dbsize^{5/6})$ 的空间缓存结果中二择其一。两者都不是令人满意的选择。因此，\cite{TreePIR,C:SACM21} 等工作改进了 hint 的组织结构，使用了更高效的 PPRF 构造。例如，\cite{TreePIR} 提出了一种称为“弱可穿孔伪随机函数（weakly Puncturable Pseudorandom Function，wPPRF）”的原语，通过将数据库分块，有效地支持高效隶属查询的同时，免去了原构造中并行多个实例的需求。然而，他们的构造引入了一种本文称之为“虚构查询”的新问题。这一问题的核心是客户端在进行一次查询时实质上进行了多次查询，但除了一条查询之外其他都是虚构的，用于混淆真是查询。这种虚构查询一方面降低了查询的效率，另一方面也导致客户端很难验证这些查询的结果。这一问题导致了这些协议很难在恶意攻击者存在时保证隐私。

\subsection{亚线性单服务器PIR}
另一部分工作 \cite{Piano,CHK22} 致力于将亚线性PIR移植到单服务器环境中。由于服务器可以对比查询和hint来获知实际查询的记录， hint 不能从一台服务器获取，又在这一台服务器使用，这使得这一移植十分困难。Corrigan-Gibbs 首先完成了这一工作，他们提出了一种将多服务器PIR编译成单服务器PIR协议的通用编译器，利用备用 hint 与同态加密技术替代了多服务器协议中一台服务器的功能。但他们的协议和最开始的多服务器协议一样，需要并行实例来确保正确性，并且需要客户端缓存大量的计算结果来保证在线查询的效率。Piano \cite{Piano} 结合了 \cite{CHK22} 与 \cite{TreePIR} 中的技术，提出了一个高效的单服务器亚线性 PIR 协议。他们指出，实际上，将整个数据库都以流式传输到客户端，然后让客户端在本地计算hint才是更现实的做法。事实上，他们也给出了第一个实际的单服务器亚线性PIR协议实现。这一协议的通信复杂度为 $O(\sqrt{\dbsize})$， 计算复杂度为$O_\lambda(\dbsize)$。尽管这一协议在效率上更进一步，它和之前提到的TreePIR一样有着“虚构查询”的问题。本文所提出的亚线性PIR框架希望解决这一问题，从而使得向恶意安全模型迁移成为可能。

\subsection{可验证的PIR}
一些工作研究了可验证PIR这一课题，致力于将PIR迁移到恶意安全模型上。这一模型最初在 \cite{FOCS:CGKS95} 中提出，在 \cite{SCN:BeiSta02, USENIX:DevGolHen12,SVPIR18, MerkleTree} 中被进一步研究。早期的工作往往集中于如何证明计算上的正确性，即正确性的假设要求其输出与某个数据库相一致，但不考虑服务器是否直接在错误的数据库上运行协议。最近的一些工作包括 \cite{VeriSimplePIR, APIR}，这些工作讨论了如何确保服务器给出的回复与某个预定义的数据库相一致。在 \cite{APIR} 中，作者系统地定义了可验证PIR，并提出了单服务器，多服务器与函数秘密分享的可验证协议。他们的多服务器协议基于默克尔证明（Merkle Proof），单服务器协议基于容错学习问题（Learning With Error, LWE）与判定性Diffie-Hellman问题（Decisional Diffie-Hellman，DDH）。同时，他们还注意到了选择失败攻击在PIR中的影响。然而，他们提出的协议在通信量与计算量上都相当低效，并不实际。另一项工作 VeriSimplePIR \cite{VeriSimplePIR} 则在 SimplePIR 的基础上增加了验证能力，通过预先运行一个验证协议，以比较小的代价将协议迁移到了恶意安全模型上。这些工作都是基于线性复杂度的PIR构造的，目前尚没有可验证的亚线性复杂度PIR协议。本文希望能够填补这一方面的空白。


